#!/bin/bash

# --- Main ---
asyncproc_start() {
    asyncproc_init
    asyncproc_say "Starting..."
    asyncproc_handler_ec_start
    asyncproc_handler_stdout_start
    asyncproc_handler_stderr_start
    asyncproc_say "Ready to run processes"
}

asyncproc_init() {
    asyncproc_conf
    declare -F asyncproc_conf_local &> /dev/null && asyncproc_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_INPUT}"
    exec 5<>${ASYNCPROC_INPUT} || asyncproc_die "Cannot assign a FD to ${ASYNCPROC_INPUT}"
}

asyncproc_conf() {
    asyncproc_basename="$(basename -s .sh $0)"
    asyncproc_namespace="main"
    export ASYNCPROC_INPUT="/tmp/${asyncproc_basename}-asyncproc.pipe"
    asyncproc_say_pre='$(date "+%Y-%m-%d %H:%M:%S") ${asyncproc_basename} [asyncproc-${asyncproc_namespace}/$BASHPID]: '
    asyncproc_err_pre="error: "
    asyncproc_die_exitcode="13"
    asyncproc_handlers=()
    asyncproc_kill_timeout="16"
    asyncproc_term_timeout="0"
    asyncproc_main_pid=$BASHPID

    asyncproc_workers=() # all "PID - Commands" in the session
    asyncproc_exitcodes=() # all "PID - Exit codes" in the session
    asyncproc_stdouts=() # all "PID - File names with stdout" in the session
    asyncproc_stderrs=() # all "PID - File names with stderr" in the session 

    asyncproc_last_workers=() # all "PID - Commands" in the current run
    asyncproc_last_exitcodes=() # all "PID - Exit codes" in the current run
    asyncproc_last_stdouts=() # all "PID - File names with stdout" in the current run
    asyncproc_last_stderrs=() # all "PID - File names with stderr" in the current run
}

asyncproc_stop() {
    asyncproc_say "Stopping..."
    asyncproc_get_exitcodes "close"
    asyncproc_get_stdouts "close"
    asyncproc_get_stderrs "close"

    asyncproc_term_procs ${asyncproc_kill_timeout} ${asyncproc_handlers[*]} &>/dev/null
    asyncproc_term_procs ${asyncproc_kill_timeout} ${!asyncproc_last_workers[*]} ${asyncproc_last_wd_pid} &>/dev/null
    
    [[ -L /proc/$$/fd/5 ]] && exec 5>&-
    if [[ -n "${ASYNCPROC_INPUT}" ]] && [[ -p ${ASYNCPROC_INPUT} ]]; then
        rm -f ${ASYNCPROC_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_INPUT}"
    fi

    asyncproc_say "Workers: ${asyncproc_workers[*]}"
    asyncproc_say "Exit codes: ${asyncproc_exitcodes[*]}"
    asyncproc_say "Files with Stdout: ${asyncproc_stdouts[*]}"
    asyncproc_say "Files with Stderr: ${asyncproc_stderrs[*]}"
    asyncproc_say "Stopped"
}

asyncproc_run() {
    :
}

# --- Exit Code handler ---
asyncproc_handler_ec_start() {
    asyncproc_handler_ec_init
    (
        trap asyncproc_handler_ec_exit EXIT
        asyncproc_namespace="ec"
        local _pid _ec _ec_k _ecs=()

        asyncproc_say "Ready to receive exit codes at ${ASYNCPROC_HANDLER_EC_INPUT}"

        while :; do
            if [[ -p ${ASYNCPROC_INPUT} ]] && [[ -L /proc/$$/fd/5 ]] && [[ -p ${ASYNCPROC_HANDLER_EC_INPUT} ]] && [[ -L /proc/$$/fd/6 ]]; then 
                read -u 6 _pid _ec
                if [[ -n "${_pid}" ]]; then
                    if [[ "${_pid}" = "dump" ]] || [[ "${_pid}" = "close" ]]; then
                        for _ec_k in ${!_ecs[*]}; do
                            echo "${_ec_k} ${_ecs[${_ec_k}]}" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                            unset _ecs[${_ec_k}]
                        done
                        echo "end" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                        [[ "${_pid}" = "close" ]] && exit
                    elif [[ ${_pid} -gt 0 ]] && [[ -n "${_ec}" ]] && [[ ${_ec} -ge 0 ]]; then
                        asyncproc_handler_ec_add _ecs ${_pid} ${_ec}
                        declare -F asyncproc_handler_ec_add_local &> /dev/null && asyncproc_handler_ec_add_local _ecs ${_pid} ${_ec} || :
                    fi
                fi
            else
                asyncproc_die "Cannot read from ${ASYNCPROC_HANDLER_EC_INPUT}"
            fi
        done
    )&
    asyncproc_handlers[0]=$!
    asyncproc_say "Exitcode handler has been started as ${asyncproc_handlers[0]}"
}

asyncproc_handler_ec_add() {
    eval $1[\$2]="\$3"
}

asyncproc_handler_ec_init() {
    asyncproc_handler_ec_conf
    declare -F asyncproc_handler_ec_conf_local &> /dev/null && asyncproc_handler_ec_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_EC_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_EC_INPUT}"
    exec 6<>${ASYNCPROC_HANDLER_EC_INPUT} || asyncproc_die "Cannot assign a FD to ${ASYNCPROC_HANDLER_EC_INPUT}"
}

asyncproc_handler_ec_conf() {
    export ASYNCPROC_HANDLER_EC_INPUT="/tmp/${asyncproc_basename}-asyncproc-ec.pipe"
}

asyncproc_handler_ec_exit() {
    [[ -L /proc/$$/fd/6 ]] && exec 6>&-
    if [[ -n "${ASYNCPROC_HANDLER_EC_INPUT}" ]] && [[ -p ${ASYNCPROC_HANDLER_EC_INPUT} ]]; then
        rm -f ${ASYNCPROC_HANDLER_EC_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_EC_INPUT}"
    fi
    asyncproc_say "Exitcode handler has exited"
}


# --- Stdout handler ---
asyncproc_handler_stdout_start() {
    asyncproc_handler_stdout_init
    (
        trap asyncproc_handler_stdout_exit EXIT
        asyncproc_namespace="stdout"
        local _pid _stdout _stdout_k _stdouts=()

        asyncproc_say "Ready to receive stdouts at ${ASYNCPROC_HANDLER_STDOUT_INPUT}"

        while :; do
            if [[ -p ${ASYNCPROC_INPUT} ]] && [[ -L /proc/$$/fd/5 ]] && [[ -p ${ASYNCPROC_HANDLER_STDOUT_INPUT} ]] && [[ -L /proc/$$/fd/7 ]]; then
                read -u 7 _pid _stdout
                if [[ -n "${_pid}" ]]; then
                    if [[ "${_pid}" = "dump" ]] || [[ "${_pid}" = "close" ]]; then
                        for _stdout_k in ${!_stdouts[*]}; do
                            echo "${_stdout_k} \"${_stdouts[${_stdout_k}]}\"" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                            unset _stdouts[${_stdout_k}]
                        done
                        echo "end" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                        [[ "${_pid}" = "close" ]] && exit
                    elif [[ ${_pid} -gt 0 ]] && [[ -n "${_stdout}" ]]; then
                        _stdouts[${_pid}]="${_stdout}"
                    fi
                fi
            else
               asyncproc_die "Cannot read from ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
            fi
        done
    )&
    asyncproc_handlers[1]=$!
    asyncproc_say "Stdout handler has been started as ${asyncproc_handlers[1]}" 
}

asyncproc_handler_stdout_init() {
    asyncproc_handler_stdout_conf
    declare -F asyncproc_handler_stdout_conf_local &> /dev/null && asyncproc_handler_stdout_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_STDOUT_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
    exec 7<>${ASYNCPROC_HANDLER_STDOUT_INPUT} || asyncproc_die "Cannot assign a FD to ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
}

asyncproc_handler_stdout_conf() {
    export ASYNCPROC_HANDLER_STDOUT_INPUT="/tmp/${asyncproc_basename}-asyncproc-stdout.pipe"
}

asyncproc_handler_stdout_exit() {
    [[ -L /proc/$$/fd/7 ]] && exec 7>&-
    if [[ -n "${ASYNCPROC_HANDLER_STDOUT_INPUT}" ]] && [[ -p ${ASYNCPROC_HANDLER_STDOUT_INPUT} ]]; then
        rm -f ${ASYNCPROC_HANDLER_STDOUT_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
    fi
    asyncproc_say "Stdout handler has exited"
}


# --- Stderr handler ---
asyncproc_handler_stderr_start() {
    asyncproc_handler_stderr_init
    (
        trap asyncproc_handler_stderr_exit EXIT
        asyncproc_namespace="stderr"
        local _pid _stderr _stderr_k _stderrs=()

        asyncproc_say "Ready to receive stderrs at ${ASYNCPROC_HANDLER_STDERR_INPUT}"

        while :; do
            if [[ -p ${ASYNCPROC_INPUT} ]] && [[ -L /proc/$$/fd/5 ]] && [[ -p ${ASYNCPROC_HANDLER_STDERR_INPUT} ]] && [[ -L /proc/$$/fd/8 ]]; then
                read -u 8 _pid _stderr
                if [[ -n "${_pid}" ]]; then
                    if [[ "${_pid}" = "dump" ]] || [[ "${_pid}" = "close" ]]; then
                        for _stderr_k in ${!_stderrs[*]}; do
                            echo "${_stderr_k} ${_stderrs[${_stderr_k}]}" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                            unset _stderrs[${_stderr_k}]
                        done
                        echo "end" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                        [[ "${_pid}" = "close" ]] && exit
                    elif [[ ${_pid} -gt 0 ]] && [[ -n "${_stderr}" ]]; then
                        _stderrs[${_pid}]="${_stderr}"
                    fi
                fi
            else
                asyncproc_die "Cannot read from ${ASYNCPROC_HANDLER_STDERR_INPUT}"
            fi
        done
    )&
    asyncproc_handlers[2]=$!
    asyncproc_say "Stderr handler has been started as ${asyncproc_handlers[2]}" 
}

asyncproc_handler_stderr_init() {
    asyncproc_handler_stderr_conf
    declare -F asyncproc_handler_stderr_conf_local &> /dev/null && asyncproc_handler_stderr_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_STDERR_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_STDERR_INPUT}"
    exec 8<>${ASYNCPROC_HANDLER_STDERR_INPUT}|| asyncproc_die "Cannot assign a FD to ${ASYNCPROC_HANDLER_STDERR_INPUT}"
}

asyncproc_handler_stderr_conf() {
    export ASYNCPROC_HANDLER_STDERR_INPUT="/tmp/${asyncproc_basename}-asyncproc-stderr.pipe"
}

asyncproc_handler_stderr_exit() {
    [[ -L /proc/$$/fd/8 ]] && exec 8>&-
    if [[ -n "${ASYNCPROC_HANDLER_STDERR_INPUT}" ]] && [[ -p ${ASYNCPROC_HANDLER_STDERR_INPUT} ]]; then
        rm -f ${ASYNCPROC_HANDLER_STDERR_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_STDERR_INPUT}"
    fi
    asyncproc_say "Stderr handler has exited"
}

# --- Common functions ---
asyncproc_say() {
    if [[ "${ASYNCPROC_VERBOSE}" = "true" ]]; then
        eval echo "${asyncproc_say_pre}$@${asyncproc_say_suf}"
    fi
}

asyncproc_err() {
    asyncproc_say "${asyncproc_err_pre}$@${asyncproc_err_suf}" >&2
}

asyncproc_die() {
    asyncproc_err "${asyncproc_die_pre}$@${asyncproc_die_suf}"
    exit ${asyncproc_die_exitcode}
}

asyncproc_wait_procs() {
    local _term_timeout _pid_k _pids=()

    _term_timeout=$1; shift
    read -a _pids <<< "$@"
}    

asyncproc_term_procs() {
    local _kill_timeout _pid_k _pids=() _watchdog=()

    _kill_timeout=$1; shift
    read -a _pids <<< "$@"

    while [[ -n "${!_pids[*]}" ]]; do
        for _pid_k in ${!_pids[*]}; do
            if [[ -z "${_pids[${_pid_k}]}" ]] || [[ ${_pids[${_pid_k}]} -eq 0 ]]; then
                unset _pids[${_pid_k}]
                continue
            fi
            
            if ps -p ${_pids[${_pid_k}]} &>/dev/null; then
                if [[ -n "${_watchdog[${_pids[${_pid_k}]}]}" ]] && [[ ${_watchdog[${_pids[${_pid_k}]}]} -gt 0 ]]; then
                    :
                else
                    kill -TERM ${_pids[${_pid_k}]}
                    ( sleep ${_kill_timeout}; kill -KILL ${_pids[${_pid_k}]} )&
                    # saving watchdog's PID in the index of process' PID
                    _watchdog[${_pids[${_pid_k}]}]=$!
                fi
            else 
                ps -p ${_watchdog[${_pids[${_pid_k}]}]} &>/dev/null && kill -TERM ${_watchdog[${_pids[${_pid_k}]}]}
                unset _wd[${_pids[${_pid_k}]}]
                unset _pids[${_pid_k}]
            fi
        done
        sleep 1
    done
}

asyncproc_get_exitcodes() {
    local _pid _ec

    if ps -p ${asyncproc_handlers[0]} &> /dev/null && \
       [[ -n "${ASYNCPROC_INPUT}" ]] && [[ -p ${ASYNCPROC_INPUT} ]] && [[ -L /proc/$$/fd/5 ]] && \
       [[ -n "${ASYNCPROC_HANDLER_EC_INPUT}" ]] && [[ -p ${ASYNCPROC_HANDLER_EC_INPUT} ]] && [[ -L /proc/$$/fd/6 ]]; then
        echo "$1" > ${ASYNCPROC_HANDLER_EC_INPUT}
        while read -u 5 _pid _ec; do
            if [[ "${_pid}" = "end" ]]; then
                break
            else
                asyncproc_exitcodes[${_pid}]=${_ec}
            fi
        done
    fi
}

asyncproc_get_stdouts() {
    local _pid _stdout

    if ps -p ${asyncproc_handlers[1]} &> /dev/null && \
       [[ -n "${ASYNCPROC_INPUT}" ]] && [[ -p ${ASYNCPROC_INPUT} ]] && [[ -L /proc/$$/fd/5 ]] && \
       [[ -n "${ASYNCPROC_HANDLER_STDOUT_INPUT}" ]] && [[ -p ${ASYNCPROC_HANDLER_STDOUT_INPUT} ]] && [[ -L /proc/$$/fd/7 ]]; then
        echo "$1" > ${ASYNCPROC_HANDLER_STDOUT_INPUT}
        while read -u 5 _pid _stdout; do
            if [[ "${_pid}" = "end" ]]; then
                break
            else
                asyncproc_stdouts[${_pid}]="${_stdout}"
            fi
        done
    fi
}

asyncproc_get_stderrs() {
    local _pid _stderr

    if ps -p ${asyncproc_handlers[1]} &> /dev/null && \
       [[ -n "${ASYNCPROC_INPUT}" ]] && [[ -p ${ASYNCPROC_INPUT} ]] && [[ -L /proc/$$/fd/5 ]] && \
       [[ -n "${ASYNCPROC_HANDLER_STDOUT_INPUT}" ]] && [[ -p ${ASYNCPROC_HANDLER_STDERR_INPUT} ]] && [[ -L /proc/$$/fd/8 ]]; then
        echo "$1" > ${ASYNCPROC_HANDLER_STDERR_INPUT}
        while read -u 5 _pid _stderr; do
            if [[ "${_pid}" = "end" ]]; then
                break
            else
                asyncproc_stderrs[${_pid}]="${_stderr}"
            fi
        done
    fi
}

